---
layout: post
title: jvm常见垃圾回收算法及双亲委派模型
---
## java虚拟机常见的垃圾回收算法

`java`相对于`C++`优势在于自动的垃圾回收，提供对象的构造函数后，不需要再提供析构函数（销毁对象，释放之前申请的内存），更易避免了内存泄露的问题。主要归功于虚拟机进行垃圾回收，虚拟机版本有`Sun`公司的`HotSopt VM`、`BEA`的`JRockit`、微软的`JVM`及`IBM`的`J9 VM`。

### 内存区域划分

`Java`虚拟机在执行程序时会把管理的内存划分为若干个不同的数据区域，这些区域有各自的用途，以及创建和销毁的时间。

1）程序计数器（`Program Counter Register`）占用一块较小的内存空间，可看作是当前线程执行字节码的行号指示器（与操作系统中的`PC`的概念相同，指定下一条指令的位置）。在执行分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。每个线程都有一个独立的程序计数器；

2）`Java`虚拟机栈也是线程私有的，声明周期与线程相同。描述`Java`方法执行的内存模型，每个方法执行会创建一个栈帧 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。递归方法调用超过最大深度时 将跑出`StackOverflowError`的异常；

3）本地方法栈（`Native Method Stack`）用于调用其它语言的方法（如`C++`），声明周期也与线程绑定；

4）`Java`堆是多个线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，也是垃圾收集器管理的主要区域。由于收集器基本采用分代收集算法，`Java`堆还可以细分为：新生代和老年代（细致些有`Eden`空间、`From Survivor`空间、`To Survivor`空间）等；

5）方法区（`Method Area`）与`Java`堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后代码等数据。在`HotSpot`中，开发者更愿意把方法去称为“永久代”（`Permanent Generation`），但本质上并不等价；

6）运行时常量池（`Runtime Constant Pool`）和直接内存（`Direct Memory`）这两部分，用于存储`class`文件翻译出来的直接引用也存储在运行时常量池中，直接内存主要用于`NIO`类；

### 回收算法及垃圾收集器

如何判断一个对象已死？已有引用计数算法，但其无法解决循环引用的问题。`java`采用可达性分析算法，算法的基本思路 是通过一系列称为"`gc roots` "的对象作为起始点，搜索所走过的路径称为引用链（`reference chain`），当`gc`不可达时 则证明此对象是不可用的。

“标记-清除”（`Mark-Sweep`）算法，首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。问题在于，一个是效率问题 标记和清除两个过程的效率都不高，另外，还会产生大量不连续的内存碎片。在分配较大对象时，容易产生`OOM`。

为了解决效率问题，一种称为复制（`copying`）的算法出现了，它将可用内存按容量划分为大小相等的两个块。每次将存活的对象复制到另一个块。但是，内存利用率不高 存在`50%`的内存浪费。目前商业虚拟机分为`1`个`80%`的`Edge`区和`2`个`10%`的`Survivor`区。

根据老年代的特点，有人提出了另外一种“标记-整理”（`Mark Compact`）算法，差异在于不清理可回收的对象，而是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。

商业上目前用的是分代回收（`Generational Collect`）算法，根据对象存活周期的不同将内存划分为几块。一般是把`Java`堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。













